option aesop.check.all : Bool := false
  (aesop) Enable all runtime checks. Individual checks can still be disabled.

option aesop.check.proofReconstruction : Bool := false
  (aesop) Typecheck partial proof terms during proof reconstruction.

option aesop.check.rules : Bool := false
  (aesop) Check that information reported by rules is correct.

option aesop.check.script : Bool := false
  (aesop) Check that the tactic script generated by Aesop proves the goal. When this check is active, Aesop generates a tactic script even if the user did not request one.

option aesop.check.script.steps : Bool := false
  (aesop) Check each step of the tactic script generated by Aesop. When this check is active, Aesop generates a tactic script even if the user did not request one.

option aesop.check.tree : Bool := false
  (aesop) Check search tree invariants after every iteration of the search loop. Quite expensive.

option aesop.collectStats : Bool := false
  (aesop) collect statistics about Aesop invocations. Use #aesop_stats to display the collected statistics.

option aesop.dev.dynamicStructuring : Bool := true
  (aesop) Only for use by Aesop developers. Enables dynamic script structuring.

option aesop.smallErrorMessages : Bool := false
  (aesop) Print smaller error messages. Used for testing.

option allowUnsafeReducibility : Bool := false
  enables users to modify the reducibility settings for declarations even when such changes are deemed potentially hazardous. For example, `simp` and type class resolution maintain term indices where reducible declarations are expanded.

option autoImplicit : Bool := true
  Unbound local variables in declaration headers become implicit arguments. In "relaxed" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, `def f (x : Vector α n) : Vector α n :=` automatically introduces the implicit variables {α n}.

option autoLift : Bool := true
  insert monadic lifts (i.e., `liftM` and coercions) when needed

option backward.isDefEq.lazyProjDelta : Bool := true
  use lazy delta reduction when solving unification constrains of the form `(f a).i =?= (g b).i`

option backward.isDefEq.lazyWhnfCore : Bool := true
  specifies transparency mode when normalizing constraints of the form `(f a).i =?= s`, if `true` only reducible definitions and instances are unfolded when reducing `f a`. Otherwise, the default setting is used

option backward.synthInstance.canonInstances : Bool := true
  use optimization that relies on 'morally canonical' instances during type class resolution

option bootstrap.genMatcherCode : Bool := true
  disable code generation for auxiliary matcher function

option bootstrap.inductiveCheckResultingUniverse : Bool := true
  by default the `inductive`/`structure` commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into `Prop`. In the `Init` package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator

option checkBinderAnnotations : Bool := true
  check whether type is a class instance whenever the binder annotation `[...]` is used

option compiler.check : Bool := true
  type check code after each compiler step (this is useful for debugging purses)

option compiler.checkTypes : Bool := false
  (compiler) perform type compatibility checking after each compiler pass. Note this is not a complete check, and it is used only for debugging purposes. It fails in code that makes heavy use of dependent types.

option compiler.enableNew : Bool := false
  (compiler) enable the new code generator, this should have no significant effect on your code but it does help to test the new code generator; unset to only use the old code generator instead

option compiler.extract_closed : Bool := true
  (compiler) enable/disable closed term caching

option compiler.maxRecInline : Nat := 1
  (compiler) maximum number of times a recursive definition tagged with `[inline]` can be recursively inlined before generating an error during compilation.

option compiler.maxRecInlineIfReduce : Nat := 16
  (compiler) maximum number of times a recursive definition tagged with `[inline_if_reduce]` can be recursively inlined before generating an error during compilation.

option compiler.reuse : Bool := true
  heuristically insert reset/reuse instruction pairs

option compiler.small : Nat := 1
  (compiler) function declarations with size `≤ small` is inlined even if there are multiple occurrences.

option debug.byAsSorry : Bool := false
  replace `by ..` blocks with `sorry` IF the expected type is a proposition

option debug.moduleNameAtTimeout : Bool := true
  include module name in deterministic timeout error messages.
  Remark: we set this option to false to increase the stability of our test suite

option debug.skipKernelTC : Bool := false
  skip kernel type checker. WARNING: setting this option to true may compromise soundness because your proofs will not be checked by the Lean kernel

option deprecated.oldSectionVars : Bool := false
  re-enable deprecated behavior of including exactly the section variables used in a declaration

option diagnostics : Bool := false
  collect diagnostic information

option diagnostics.threshold : Nat := 20
  only diagnostic counters above this threshold are reported by the definitional equality

option exponentiation.threshold : Nat := 256
  maximum value for which exponentiation operations are safe to evaluate. When an exponent is a value greater than this threshold, the exponentiation will not be evaluated, and a warning will be logged. This helps to prevent the system from becoming unresponsive due to excessively large computations.

option format.indent : Nat := 2
  indentation

option format.inputWidth : Nat := 100
  ideal input width

option format.unicode : Bool := true
  unicode characters

option format.width : Nat := 120
  indentation

option genInjectivity : Bool := true
  generate injectivity theorems for inductive datatype constructors

option genSizeOf : Bool := true
  generate `SizeOf` instance for inductive types and structures

option genSizeOfSpec : Bool := true
  generate `SizeOf` specification theorems for automatically generated instances

option guard_msgs.diff : Bool := false
  When true, show a diff between expected and actual messages if they don't match.

option hygiene : Bool := true
  Annotate identifiers in quotations such that they are resolved relative to the scope at their declaration, not that at their eventual use/expansion, to avoid accidental capturing. Note that quotations/notations already defined are unaffected.

option inductive.autoPromoteIndices : Bool := true
  Promote indices to parameters in inductive types whenever possible.

option infoview.maxTraceChildren : Nat := 50
  Number of trace node children to display by default

option internal.parseQuotWithCurrentStage : Bool := false
  (Lean bootstrapping) use parsers from the current stage inside quotations

option interpreter.prefer_native : Bool := true
  (interpreter) whether to use precompiled code where available

option lang.lemmaCmd : Bool := false
  enable the use of the `lemma` command as a synonym for `theorem`

option linter.all : Bool := false
  enable all linters

option linter.cdot : Bool := true
  enable the `cdot` linter

option linter.constructorNameAsVariable : Bool := true
  enable the linter that warns when bound variable names are nullary constructor names

option linter.deprecated : Bool := true
  if true, generate deprecation warnings

option linter.dupNamespace : Bool := true
  enable the duplicated namespace linter

option linter.existingAttributeWarning : Bool := true
  Linter, mostly used by `@[to_additive]`, that checks that the source declaration doesn't have certain attributes

option linter.globalAttributeIn : Bool := true
  enable the globalAttributeIn linter

option linter.hashCommand : Bool := true
  enable the `#`-command linter

option linter.haveLet : Nat := 1
  enable the `have` vs `let` linter:
  * 0 -- inactive;
  * 1 -- active only on noisy declarations;
  * 2 or more -- always active.

option linter.longLine : Bool := true
  enable the longLine linter

option linter.minImports : Bool := false
  enable the minImports linter

option linter.missingDocs : Bool := false
  enable the 'missing documentation' linter

option linter.missingEnd : Bool := true
  enable the missing end linter

option linter.oldObtain : Bool := true
  enable the `oldObtain` linter

option linter.refine : Bool := true
  enable the refine linter

option linter.setOption : Bool := true
  enable the `setOption` linter

option linter.simpsNoConstructor : Bool := true
  Linter to check that `simps!` is used

option linter.simpsUnusedCustomDeclarations : Bool := true
  Linter to check that no unused custom declarations are declared for simps

option linter.suspiciousUnexpanderPatterns : Bool := true
  enable the 'suspicious unexpander patterns' linter

option linter.toAdditiveExisting : Bool := true
  Linter used by `@[to_additive]` that checks whether the user correctly specified that
      the additive declaration already exists

option linter.toAdditiveGenerateName : Bool := true
  Linter used by `@[to_additive]` that checks if `@[to_additive]` automatically generates the user-given name

option linter.toAdditiveReorder : Bool := true
  Linter to check that the reorder attribute is not given manually.

option linter.unnecessarySeqFocus : Bool := true
  enable the 'unnecessary <;>' linter

option linter.unnecessarySimpa : Bool := true
  enable the 'unnecessary simpa' linter

option linter.unreachableTactic : Bool := true
  enable the 'unreachable tactic' linter

option linter.unusedRCasesPattern : Bool := true
  enable the 'unused rcases pattern' linter

option linter.unusedTactic : Bool := true
  enable the unused tactic linter

option linter.unusedVariables : Bool := true
  enable the 'unused variables' linter

option linter.unusedVariables.funArgs : Bool := true
  enable the 'unused variables' linter to mark unused function arguments

option linter.unusedVariables.patternVars : Bool := true
  enable the 'unused variables' linter to mark unused pattern variables

option match.ignoreUnusedAlts : Bool := false
  if true, do not generate error if an alternative is not used

option maxBackwardChainingDepth : Nat := 10
  The maximum search depth used in the backwards chaining part of the proof of `brecOn` for inductive predicates.

option maxHeartbeats : Nat := 200000
  maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit

option maxRecDepth : Nat := 512
  maximum recursion depth for many Lean procedures

option maxSynthPendingDepth : Nat := 1
  maximum number of nested `synthPending` invocations. When resolving unification constraints, pending type class problems may need to be synthesized. These type class problems may create new unification constraints that again require solving new type class problems. This option puts a threshold on how many nested problems are created.

option maxUniverseOffset : Nat := 32
  maximum universe level offset

option pp.all : Bool := false
  (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing

option pp.analyze : Bool := false
  (pretty printer analyzer) determine annotations sufficient to ensure round-tripping

option pp.analyze.checkInstances : Bool := false
  (pretty printer analyzer) confirm that instances can be re-synthesized

option pp.analyze.explicitHoles : Bool := false
  (pretty printer analyzer) use `_` for explicit arguments that can be inferred

option pp.analyze.knowsType : Bool := true
  (pretty printer analyzer) assume the type of the original expression is known

option pp.analyze.omitMax : Bool := true
  (pretty printer analyzer) omit universe `max` annotations (these constraints can actually hurt)

option pp.analyze.trustId : Bool := true
  (pretty printer analyzer) always assume an implicit `fun x => x` can be inferred

option pp.analyze.trustKnownFOType2TypeHOFuns : Bool := true
  (pretty printer analyzer) omit higher-order functions whose values seem to be knownType2Type

option pp.analyze.trustOfNat : Bool := true
  (pretty printer analyzer) always 'pretend' `OfNat.ofNat` applications can elab bottom-up

option pp.analyze.trustOfScientific : Bool := true
  (pretty printer analyzer) always 'pretend' `OfScientific.ofScientific` applications can elab bottom-up

option pp.analyze.trustSubst : Bool := false
  (pretty printer analyzer) always 'pretend' applications that can delab to ▸ are 'regular'

option pp.analyze.trustSubtypeMk : Bool := true
  (pretty printer analyzer) assume the implicit arguments of Subtype.mk can be inferred

option pp.analyze.typeAscriptions : Bool := true
  (pretty printer analyzer) add type ascriptions when deemed necessary

option pp.auxDecls : Bool := false
  display auxiliary declarations used to compile recursive functions

option pp.beta : Bool := false
  (pretty printer) apply beta-reduction when pretty printing

option pp.coercions : Bool := true
  (pretty printer) hide coercion applications

option pp.deepTerms : Bool := false
  (pretty printer) display deeply nested terms, replacing them with `⋯` if set to false

option pp.deepTerms.threshold : Nat := 50
  (pretty printer) when `pp.deepTerms` is false, the depth at which terms start being replaced with `⋯`

option pp.explicit : Bool := false
  (pretty printer) display implicit arguments

option pp.fieldNotation : Bool := true
  (pretty printer) use field notation when pretty printing, including for structure projections, unless '@[pp_nodot]' is applied

option pp.fieldNotation.generalized : Bool := true
  (pretty printer) when `pp.fieldNotation` is true, enable using generalized field notation when the argument for field notation is the first explicit argument

option pp.fullNames : Bool := false
  (pretty printer) display fully qualified names

option pp.funBinderTypes : Bool := false
  (pretty printer) display types of lambda parameters

option pp.implementationDetailHyps : Bool := false
  display implementation detail hypotheses in the local context

option pp.inaccessibleNames : Bool := true
  display inaccessible declarations in the local context

option pp.instanceTypes : Bool := false
  (pretty printer) when printing explicit applications, show the types of inst-implicit arguments

option pp.instances : Bool := true
  (pretty printer) if set to false, replace inst-implicit arguments to explicit applications with placeholders

option pp.instantiateMVars : Bool := true
  (pretty printer) instantiate mvars before delaborating

option pp.letVarTypes : Bool := false
  (pretty printer) display types of let-bound variables

option pp.macroStack : Bool := false
  display macro expansion stack

option pp.match : Bool := true
  (pretty printer) disable/enable 'match' notation

option pp.maxSteps : Nat := 5000
  (pretty printer) maximum number of expressions to visit, after which terms will pretty print as `⋯`

option pp.motives.all : Bool := false
  (pretty printer) print all motives

option pp.motives.nonConst : Bool := false
  (pretty printer) print all motives that are not constant functions

option pp.motives.pi : Bool := true
  (pretty printer) print all motives that return pi types

option pp.mvars : Bool := true
  (pretty printer) display names of metavariables when true, and otherwise display them as '?_' (for expression metavariables) and as '_' (for universe level metavariables)

option pp.mvars.withType : Bool := false
  (pretty printer) display metavariables with a type ascription

option pp.natLit : Bool := false
  (pretty printer) display raw natural number literals with `nat_lit` prefix

option pp.notation : Bool := true
  (pretty printer) disable/enable notation (infix, mixfix, postfix operators and unicode characters)

option pp.numericTypes : Bool := false
  (pretty printer) display types of numeric literals

option pp.oneline : Bool := false
  (pretty printer) elide all but first line of pretty printer output

option pp.piBinderTypes : Bool := true
  (pretty printer) display types of pi parameters

option pp.privateNames : Bool := false
  (pretty printer) display internal names assigned to private declarations

option pp.proofs : Bool := false
  (pretty printer) display proofs when true, and replace proofs appearing within expressions by `⋯` when false

option pp.proofs.threshold : Nat := 0
  (pretty printer) when `pp.proofs` is false, controls the complexity of proofs at which they begin being replaced with `⋯`

option pp.proofs.withType : Bool := false
  (pretty printer) when `pp.proofs` is false, adds a type ascription to the omitted proof

option pp.qq : Bool := true
  (pretty printer) print quotations as q(...) and Q(...)

option pp.raw : Bool := false
  (pretty printer) print raw expression/syntax tree

option pp.raw.maxDepth : Nat := 32
  (pretty printer) maximum `Syntax` depth for raw printer

option pp.raw.showInfo : Bool := false
  (pretty printer) print `SourceInfo` metadata with raw printer

option pp.rawOnError : Bool := false
  (pretty printer) fallback to 'raw' printer when pretty printer fails

option pp.safeShadowing : Bool := true
  (pretty printer) allow variable shadowing if there is no collision

option pp.sanitizeNames : Bool := true
  add suffix to shadowed/inaccessible variables when pretty printing

option pp.showLetValues : Bool := true
  display let-declaration values in the info view

option pp.structureInstanceTypes : Bool := false
  (pretty printer) display type of structure instances

option pp.structureInstances : Bool := true
  (pretty printer) display structure instances using the '{ fieldName := fieldValue, ... }' notation, or using '⟨fieldValue, ... ⟩' if structure is tagged with the '@[pp_using_anonymous_constructor]' attribute

option pp.structureInstances.flatten : Bool := true
  (pretty printer) flatten nested structure instances for parent projections

option pp.tagAppFns : Bool := false
  (pretty printer) tag all constants that are the function in a function application

option pp.unicode.fun : Bool := false
  (pretty printer) disable/enable unicode ↦ notation for functions

option pp.universes : Bool := false
  (pretty printer) display universe

option printMessageEndPos : Bool := false
  print end position of each message in addition to start position

option profiler : Bool := false
  show exclusive execution times of various Lean components

  See also `trace.profiler` for an alternative profiling system with structured output.

option profiler.threshold : Nat := 100
  threshold in milliseconds, profiling times under threshold will not be reported individually

option push_neg.use_distrib : Bool := false
  Make `push_neg` use `not_and_or` rather than the default `not_and`.

option quotPrecheck : Bool := true
  Enable eager name analysis on notations in order to find unbound identifiers early.
  Note that type-sensitive syntax ("elaborators") needs special support for this kind of check, so it might need to be turned off when using such syntax.

option quotPrecheck.allowSectionVars : Bool := false
  Allow occurrences of section variables in checked quotations, it is useful when declaring local notation.

option relaxedAutoImplicit : Bool := true
  When "relaxed" mode is enabled, any atomic nonempty identifier is eligible for auto bound implicit locals (see optin `autoBoundImplicitLocal`.

option says.no_verify_in_CI : Bool := false
  Disable reverification, even if `the `CI` environment variable is set.

option says.verify : Bool := false
  For every appearance of the `X says Y` combinator, re-verify that running `X` produces `Try this: Y`.

option server.reportDelayMs : Nat := 200
  (server) time in milliseconds to wait before reporting progress and diagnostics on document edit in order to reduce flickering

  This option can only be set on the command line, not in the lakefile or via `set_option`.

option showInferredTerminationBy : Bool := false
  In recursive definitions, show the inferred `termination_by` measure.

option showPartialSyntaxErrors : Bool := false
  show elaboration errors from partial syntax trees (i.e. after parser recovery)

option showTacticDiff : Bool := true
  When true, interactive goals for tactics will be decorated with diffing information.

option simprocs : Bool := true
  Enable/disable `simproc`s (simplification procedures).

option smartUnfolding : Bool := true
  when computing weak head normal form, use auxiliary definition created for functions defined by structural recursion

option stderrAsMessages : Bool := true
  (server) capture output to the Lean stderr channel (such as from `dbg_trace`) during elaboration of a command as a diagnostic message

option structureDiamondWarning : Bool := false
  enable/disable warning messages for structure diamonds

option synthInstance.checkSynthOrder : Bool := true
  check that instances do not introduce metavariable in non-out-params

option synthInstance.maxHeartbeats : Nat := 20000
  maximum amount of heartbeats per typeclass resolution problem. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit

option synthInstance.maxSize : Nat := 128
  maximum number of instances used to construct a solution in the type class instance synthesis procedure

option tactic.customEliminators : Bool := true
  enable using custom eliminators in the 'induction' and 'cases' tactics defined using the '@[induction_eliminator]' and '@[cases_eliminator]' attributes

option tactic.dbg_cache : Bool := false
  enable tactic cache debug messages (remark: they are sent to the standard error)

option tactic.hygienic : Bool := true
  make sure tactics are hygienic

option tactic.simp.trace : Bool := false
  When tracing is enabled, calls to `simp` or `dsimp` will print an equivalent `simp only` call.

option tactic.skipAssignedInstances : Bool := true
  in the `rw` and `simp` tactics, if an instance implicit argument is assigned, do not try to synthesize instance.

option trace.Aesop.Util.EqualUpToIds : Bool := false
  enable/disable tracing for the given module and submodules

option trace.CancelDenoms : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.commonJoinPointArgs : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.cse : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.eagerLambdaLifting : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.elimDeadBranches : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.extendJoinPointContext : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.findJoinPoints : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.floatLetIn : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.init : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.jp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.lambdaLifting : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.pullFunDecls : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.pullInstances : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.reduceArity : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.reduceJpArity : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.result : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.saveBase : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.saveMono : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.simp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.simp.inline : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.simp.jpCases : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.simp.stat : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.simp.step : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.simp.step.new : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.specialize : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.specialize.candidate : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.specialize.info : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.specialize.step : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.stat : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.test : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.toMono : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Compiler.trace : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Debug.Meta.Tactic.cc : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Debug.Meta.Tactic.cc.ac : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Debug.Meta.Tactic.cc.parentOccs : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Debug.Meta.Tactic.fun_prop : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Debug.Meta.Tactic.simp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Debug.Meta.Tactic.simp.congr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.RpcEncodable : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.beq : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.decEq : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.fintype : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.hashable : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.inhabited : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.ord : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.repr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.Deriving.toExpr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.ProxyType : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.app : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.app.args : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.app.elab_as_elim : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.app.finalize : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.app.propagateExpectedType : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.autoParam : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.axiom : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.binop : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.binrel : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.cases : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.coe : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.command : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.congr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.debug : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.defaultInstance : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.body : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.eqns : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.mkClosure : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.scc : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.structural : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.structural.eqns : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.unfoldEqn : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.wf : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.definition.wf.eqns : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.do : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.fbinop : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.implicitForall : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.induction : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.inductive : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.info : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.input : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.instance.mkInstanceName : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.let : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.let.decl : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.letrec : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.lint : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.match : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.match_syntax : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.match_syntax.alt : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.match_syntax.onMatch : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.match_syntax.result : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.postpone : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.resume : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.reuse : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.snapshotTree : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.step : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.step.result : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.struct : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.struct.modifyOp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.structure : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.tactic : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Elab.tactic.backtrack : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Kernel : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.AC : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.CongrTheorems : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.FunInd : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.IndPredBelow : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.IndPredBelow.match : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.IndPredBelow.search : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Match : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Match.debug : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Match.match : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Match.matchEqs : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Match.unify : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.acyclic : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.cases : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.cc.failure : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.cc.merge : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.contradiction : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.fun_prop : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.fun_prop.attr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.induction : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.polyrith : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.all : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.congr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.discharge : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.ground : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.heads : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.numSteps : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.rewrite : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.simp.unify : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.solveByElim : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.splitIf : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.Tactic.subst : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.appBuilder : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.appBuilder.error : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.appBuilder.result : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.check : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.debug : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.gcongr : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.injective : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign.beforeMkLambda : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign.checkTypes : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign.occursCheck : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign.outOfScopeFVar : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign.readOnlyMVarWithBiggerLCtx : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.assign.typeError : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.cache : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.constApprox : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.delta : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.delta.unfoldLeft : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.delta.unfoldLeftRight : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.delta.unfoldRight : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.eta.struct : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.foApprox : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.hint : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.onFailure : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.stuck : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.stuckMVar : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isDefEq.whnf.reduceBinOp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isLevelDefEq : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isLevelDefEq.postponed : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isLevelDefEq.step : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.isLevelDefEq.stuck : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.sizeOf : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.sizeOf.aux : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.sizeOf.loop : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.sizeOf.minor : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.sizeOf.minor.step : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance.answer : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance.instances : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance.newAnswer : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance.resume : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance.tryResolve : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthInstance.unusedArgs : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthOrder : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.synthPending : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Meta.whnf : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.delab : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.delab.input : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.format : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.format.backtrack : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.format.input : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.parenthesize : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.parenthesize.backtrack : Bool := false
  enable/disable tracing for the given module and submodules

option trace.PrettyPrinter.parenthesize.input : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.compute_degree : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.congrm : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.field_simp : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.generalize_proofs : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.librarySearch : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.librarySearch.lemmas : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.move_oper : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.norm_cast : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.norm_num : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.positivity : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.positivity.failure : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.propose : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.rewrites : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.rewrites.lemmas : Bool := false
  enable/disable tracing for the given module and submodules

option trace.Tactic.trans : Bool := false
  enable/disable tracing for the given module and submodules

option trace.abel : Bool := false
  enable/disable tracing for the given module and submodules

option trace.abel.detail : Bool := false
  enable/disable tracing for the given module and submodules

option trace.adaptationNote : Bool := false
  enable/disable tracing for the given module and submodules

option trace.aesop : Bool := false
  (aesop) Print actions taken by Aesop during the proof search.

option trace.aesop.debug : Bool := false
  (aesop) Print various debugging information.

option trace.aesop.extraction : Bool := false
  (aesop) Print a trace of the proof extraction procedure.

option trace.aesop.proof : Bool := false
  (aesop) If the search is successful, print the produced proof term.

option trace.aesop.ruleSet : Bool := false
  (aesop) Print the rule set before starting the search.

option trace.aesop.stats : Bool := false
  (aesop) If the search is successful, print some statistics.

option trace.aesop.tree : Bool := false
  (aesop) Once the search has concluded (successfully or unsuccessfully), print the final search tree.

option trace.apply_fun : Bool := false
  enable/disable tracing for the given module and submodules

option trace.bound.attribute : Bool := false
  enable/disable tracing for the given module and submodules

option trace.compiler : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.cce : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.code_gen : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.cse : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.eager_lambda_lifting : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.elim_dead_let : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.erase_irrelevant : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.eta_expand : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.extract_closed : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.inline : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.input : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.borrow : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.boxing : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.elim_dead : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.elim_dead_branches : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.expand_reset_reuse : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.init : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.push_proj : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.rc : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.reset_reuse : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.result : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ir.simp_case : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.lambda_lifting : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.lambda_pure : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.lcnf : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.ll_infer_type : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.llnf : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.optimize_bytecode : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.reduce_arity : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.result : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.simp : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.simp_app_args : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.simp_detail : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.simp_float_cases : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.spec_candidate : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.spec_info : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.specialize : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.stage1 : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.stage2 : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.compiler.struct_cases_on : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.congr! : Bool := false
  enable/disable tracing for the given module and submodules

option trace.congr!.synthesize : Bool := false
  enable/disable tracing for the given module and submodules

option trace.debug : Bool := false
  (trace) enable/disable tracing for the given module and submodules

option trace.explode : Bool := false
  enable/disable tracing for the given module and submodules

option trace.linarith : Bool := false
  enable/disable tracing for the given module and submodules

option trace.linarith.detail : Bool := false
  enable/disable tracing for the given module and submodules

option trace.notation3 : Bool := false
  enable/disable tracing for the given module and submodules

option trace.omega : Bool := false
  enable/disable tracing for the given module and submodules

option trace.pp.analyze : Bool := false
  enable/disable tracing for the given module and submodules

option trace.pp.analyze.annotate : Bool := false
  enable/disable tracing for the given module and submodules

option trace.pp.analyze.error : Bool := false
  enable/disable tracing for the given module and submodules

option trace.pp.analyze.tryUnify : Bool := false
  enable/disable tracing for the given module and submodules

option trace.profiler : Bool := false
  activate nested traces with execution time above `trace.profiler.threshold` and annotate with time

option trace.profiler.output : String := ""
  output `trace.profiler` data in Firefox Profiler-compatible format to given file path

option trace.profiler.output.pp : Bool := false
  if false, limit text in exported trace nodes to trace class name and `TraceData.tag`, if any

  This is useful when we are interested in the time taken by specific subsystems instead of specific invocations, which is the common case.

option trace.profiler.threshold : Nat := 10
  threshold in milliseconds (or heartbeats if `trace.profiler.useHeartbeats` is true), traces below threshold will not be activated

option trace.profiler.useHeartbeats : Bool := false
  if true, measure and report heartbeats instead of seconds

option trace.rw_search : Bool := false
  enable/disable tracing for the given module and submodules

option trace.rw_search.detail : Bool := false
  enable/disable tracing for the given module and submodules

option trace.saturate : Bool := false
  enable/disable tracing for the given module and submodules

option trace.simps.debug : Bool := false
  enable/disable tracing for the given module and submodules

option trace.simps.verbose : Bool := false
  enable/disable tracing for the given module and submodules

option trace.slim_check.decoration : Bool := false
  enable/disable tracing for the given module and submodules

option trace.slim_check.discarded : Bool := false
  enable/disable tracing for the given module and submodules

option trace.slim_check.instance : Bool := false
  enable/disable tracing for the given module and submodules

option trace.slim_check.shrink.candidates : Bool := false
  enable/disable tracing for the given module and submodules

option trace.slim_check.shrink.steps : Bool := false
  enable/disable tracing for the given module and submodules

option trace.slim_check.success : Bool := false
  enable/disable tracing for the given module and submodules

option trace.split.debug : Bool := false
  enable/disable tracing for the given module and submodules

option trace.split.failure : Bool := false
  enable/disable tracing for the given module and submodules

option trace.tactic.use : Bool := false
  enable/disable tracing for the given module and submodules

option trace.tauto : Bool := false
  enable/disable tracing for the given module and submodules

option trace.to_additive : Bool := false
  enable/disable tracing for the given module and submodules

option trace.to_additive_detail : Bool := false
  enable/disable tracing for the given module and submodules

option trace.variable? : Bool := false
  enable/disable tracing for the given module and submodules

option variable?.checkRedundant : Bool := true
  Warn if instance arguments can be inferred from preceding ones

option variable?.maxSteps : Nat := 15
  The maximum number of instance arguments `variable?` will try to insert before giving up

option warningAsError : Bool := false
  treat warnings as errors
